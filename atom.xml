<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Caydyn Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://http://caydyn-skd.github.io/"/>
  <updated>2016-04-01T03:41:36.000Z</updated>
  <id>http://http://caydyn-skd.github.io/</id>
  
  <author>
    <name><![CDATA[Caydyn]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Wireshark-2.0.1 源码分析]]></title>
    <link href="http://http://caydyn-skd.github.io/2016/04/01/Wireshark-2-0-1-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://http://caydyn-skd.github.io/2016/04/01/Wireshark-2-0-1-源码分析/</id>
    <published>2016-04-01T03:38:17.000Z</published>
    <updated>2016-04-01T03:41:36.000Z</updated>
    <content type="html"><![CDATA[<h3 id="u672C_u6587_u7EAF_u5E72_u8D27_u4EC5_u4E3A_u53CB_u7F16_u7801_u80FD_u529B_u670B_u53CB_u8BBE_u8BA1"><a href="#u672C_u6587_u7EAF_u5E72_u8D27_u4EC5_u4E3A_u53CB_u7F16_u7801_u80FD_u529B_u670B_u53CB_u8BBE_u8BA1" class="headerlink" title="本文纯干货仅为友编码能力朋友设计"></a>本文纯干货仅为友编码能力朋友设计</h3><h4 id="0x1-__u5173_u4E8ETshark_u6E90_u7801_u5206_u6790"><a href="#0x1-__u5173_u4E8ETshark_u6E90_u7801_u5206_u6790" class="headerlink" title="0x1. 关于Tshark源码分析"></a>0x1. 关于Tshark源码分析</h4><h5 id="1-_open_pcap_file"><a href="#1-_open_pcap_file" class="headerlink" title="1. open pcap file"></a>1. open pcap file</h5><pre><code>-&gt; cf_status_t cf_open(capture_file *, const char *, unsigned int, gboolean, int *);                tshark.c
    -&gt; wtap * wtap_open_offline(const char *, unsigned int, int *, char **, gboolean);                wiretap/file_access.c
        -&gt; void init_open_routines();                                                                wiretap/file_access.c
            -&gt; wtap_open_return_val libpcap_open(wtap *, int *, gchar **);                            wiretap/libpcap.c
                {
                    ……
                    wth-&gt;subtype_read = libpcap_read;
                    wth-&gt;subtype_seek_read = libpcap_seek_read;
                    ……
                }
</code></pre><h5 id="2-_read_pcpa_file__28read_buffer_3A_wtap-_26gt_3Bframe_buffer_29"><a href="#2-_read_pcpa_file__28read_buffer_3A_wtap-_26gt_3Bframe_buffer_29" class="headerlink" title="2. read pcpa file (read buffer: wtap-&gt;frame_buffer)"></a>2. read pcpa file (read buffer: wtap-&gt;frame_buffer)</h5><pre><code>-&gt; gboolean wtap_read(wtap *, int *, gchar **, gint64 *);                                            wiretap/wtap.c
    -&gt; static gboolean libpcap_read(wtap *, int *, gchar **, gint64 *);                                wiretap/libpcap.c

        -&gt; static gboolean libpcap_read_packet(wtap *, FILE_T , struct wtap_pkthdr *,
            Buffer *, int *, gchar **);                                                                wiretap/libpcap.c
                -&gt; static int libpcap_read_header(wtap *, FILE_T, int *, gchar **,
                    struct pcaprec_ss990915_hdr *);                                                    wiretap/libpcap.c
                    -&gt; gboolean wtap_read_bytes_or_eof(FILE_T, void *, unsigned int,
                        int *, gchar **);                                                            wiretap/wtap.c
                        -&gt; int file_read(void *, unsigned int, FILE_T);                                wiretap/file_wrappers.c

        -&gt; gboolean wtap_read_packet_bytes(FILE_T, Buffer *, guint, int *, gchar **);                wiretap//wtap.c
            -&gt;     void ws_buffer_assure_space(Buffer*, gsize);                                        wsutil/buffer.c
                guint8 * ws_buffer_start_ptr(Buffer* buffer);                                        wsutil/buffer.c
                    -&gt; gboolean wtap_read_bytes(FILE_T, void *, unsigned int, int *, gchar **)        wiretap//wtap.c
                        -&gt; int file_read(void *, unsigned int, FILE_T);                                wiretap/file_wrappers.c
</code></pre><h5 id="3-_analysis_packet"><a href="#3-_analysis_packet" class="headerlink" title="3. analysis packet"></a>3. analysis packet</h5><pre><code>-&gt; guint8 *wtap_buf_ptr(wtap *);                                                                    wiretap/wtap.c
-&gt; static gboolean process_packet(capture_file *, epan_dissect_t *, gint64, struct wtap_pkthdr *,
    const guchar *, guint);                                                                            tshark.c
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="u672C_u6587_u7EAF_u5E72_u8D27_u4EC5_u4E3A_u53CB_u7F16_u7801_u80FD_u529B_u670B_u53CB_u8BBE_u8BA1"><a href="#u672C_u6587_u7EAF_u5E72_u]]>
    </summary>
    
      <category term="SCA" scheme="http://http://caydyn-skd.github.io/tags/SCA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[WLAN相关名词]]></title>
    <link href="http://http://caydyn-skd.github.io/2016/02/22/WLAN%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D/"/>
    <id>http://http://caydyn-skd.github.io/2016/02/22/WLAN相关名词/</id>
    <published>2016-02-22T07:41:36.000Z</published>
    <updated>2016-04-01T03:35:37.000Z</updated>
    <content type="html"><![CDATA[<h5 id="1-_MSDU__28MAC_u670D_u52A1_u6570_u636E_u5355_u5143_29"><a href="#1-_MSDU__28MAC_u670D_u52A1_u6570_u636E_u5355_u5143_29" class="headerlink" title="1. MSDU (MAC服务数据单元)"></a>1. MSDU (MAC服务数据单元)</h5><ul>
<li>MPDU就是指的经过802.11协议封装过的数据帧。</li>
<li>MSDU是从位于一个协议栈的媒体访问控制（MAC）子层上面的逻辑链路控制（LLC）子层接收到的服务数据单元。LLC和MAC子层被统称为该DLL。</li>
<li>MSDU是MAC层服务数据单元，表示MAC层载荷；当MAC层协议数据单元(MPDU)被发送到物理层(PHY)时，它便成为了物理层服务数据单元(PSDU)。</li>
</ul>
<h5 id="2-_MPDU__28MAC_u534F_u8BAE_u6570_u636E_u5355_u5143_29"><a href="#2-_MPDU__28MAC_u534F_u8BAE_u6570_u636E_u5355_u5143_29" class="headerlink" title="2. MPDU (MAC协议数据单元)"></a>2. MPDU (MAC协议数据单元)</h5><ul>
<li>MSDU经过添加完整性校验MIC、分帧、添加IV、加密、添加MAC头部后，成为MPDU（MAC Protocol Data Unit，MAC协议数据单元）.</li>
</ul>
<h5 id="3-_A-MSDU__28_u805A_u5408MAC_u670D_u52A1_u6570_u636E_u5355_u5143_29"><a href="#3-_A-MSDU__28_u805A_u5408MAC_u670D_u52A1_u6570_u636E_u5355_u5143_29" class="headerlink" title="3. A-MSDU (聚合MAC服务数据单元)"></a>3. A-MSDU (聚合MAC服务数据单元)</h5><ul>
<li>将若干个A-MSDU Subframe按照802.11协议格式，封装成一个MPDU报文单元</li>
</ul>
<h5 id="4-_A-MPDU__28_u805A_u5408MAC_u534F_u8BAE_u6570_u636E_u5355_u5143_29"><a href="#4-_A-MPDU__28_u805A_u5408MAC_u534F_u8BAE_u6570_u636E_u5355_u5143_29" class="headerlink" title="4. A-MPDU (聚合MAC协议数据单元)"></a>4. A-MPDU (聚合MAC协议数据单元)</h5><ul>
<li>为减小开销，802.11n提出的帧汇聚技术，可把两个以上帧组成一个帧传输。</li>
<li>通过将多个MPDU聚合为一个物理层报文，只需要进行一次新到竞争或退避，既可以完成<strong>N</strong>个<strong>MPDU</strong>的同时发送，从而减少了发送<strong>N－1</strong>个<strong>MPDU</strong>报文所带来的信道资源消耗。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h5 id="1-_MSDU__28MAC_u670D_u52A1_u6570_u636E_u5355_u5143_29"><a href="#1-_MSDU__28MAC_u670D_u52A1_u6570_u636E_u5355_u5143_29" class="heade]]>
    </summary>
    
      <category term="wireless" scheme="http://http://caydyn-skd.github.io/tags/wireless/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux Kernel线程]]></title>
    <link href="http://http://caydyn-skd.github.io/2016/01/11/Linux-Kernel%E7%BA%BF%E7%A8%8B/"/>
    <id>http://http://caydyn-skd.github.io/2016/01/11/Linux-Kernel线程/</id>
    <published>2016-01-11T12:49:44.000Z</published>
    <updated>2016-01-18T08:39:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00_Kernel_API"><a href="#0x00_Kernel_API" class="headerlink" title="0x00 Kernel API"></a><strong>0x00</strong> Kernel API</h2><h3 id="u4F7F_u7528_u5230_u7684_u5934_u6587_u4EF6"><a href="#u4F7F_u7528_u5230_u7684_u5934_u6587_u4EF6" class="headerlink" title="使用到的头文件"></a>使用到的头文件</h3><pre><code>#include &lt;linux/sched.h&gt;
#include &lt;linux/kthread.h&gt;
</code></pre><a id="more"></a>
<h3 id="u76F8_u5173_u51FD_u6570_u89E3_u91CA"><a href="#u76F8_u5173_u51FD_u6570_u89E3_u91CA" class="headerlink" title="相关函数解释"></a>相关函数解释</h3><ul>
<li><p>创建 Kernel 线程  </p>
<pre><code>struct task_struct *kthread_create(int (*threadfn)(void *data),void *data,const char *namefmt, ...);
</code></pre><p>  <em>参数说明：</em></p>
<ul>
<li><strong>threadfn</strong>     需要执行的主要逻辑</li>
<li><strong>data</strong>        主逻辑传入参数</li>
<li><strong>namefmt</strong>        线程名称  </li>
</ul>
</li>
</ul>
<p>创建的线程返回<code>struct task_struct</code>指针，<strong>不会立即运行</strong></p>
<hr>
<ul>
<li><p>创建并且启动 Kernel 线程  </p>
<pre><code>struct task_struct *kthread_run(int (*threadfn)(void *data),void *data,const char *namefmt, ...);
</code></pre><p>  <em>参数说明：</em></p>
<ul>
<li><strong>threadfn</strong>     需要执行的主要逻辑</li>
<li><strong>data</strong>        主逻辑传入参数</li>
<li><strong>namefmt</strong>        线程名称  </li>
</ul>
</li>
</ul>
<p>创建的线程返回<code>struct task_struct</code>指针，<strong>会立即运行</strong></p>
<hr>
<ul>
<li><p>启动创建的 Kernel 线程</p>
<pre><code>int wake_up_process(struct task_struct *tsk);
</code></pre><p>  <em>参数说明：</em></p>
<ul>
<li><strong>thread</strong>     通过<code>kthread_create</code>创建线程后返回的结构体</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>线程停止</p>
<pre><code>int kthread_stop(struct task_struct *thread);  
</code></pre><p>  <em>参数说明：</em></p>
<ul>
<li><strong>thread</strong>     通过<code>kthread_create</code>或者<code>kthread_run</code>创建线程后返回的结构体</li>
</ul>
</li>
<li><p>线程优先级调整</p>
<pre><code>int sched_setscheduler(struct task_struct *p, int policy, struct sched_param *param);
</code></pre><p>  <em>参数说明：</em></p>
<ul>
<li><strong>p</strong>     通过<code>kthread_create</code>创建线程后返回的结构体</li>
<li><strong>policy</strong> 调度策略类型</li>
<li><strong>param</strong>  调度优先级</li>
</ul>
</li>
<li><p><em>关于policy参数</em></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>SCHED_OTHER</td>
<td style="text-align:center">分时调度策略</td>
</tr>
<tr>
<td>SCHED_FIFO</td>
<td style="text-align:center">实时调度策略，先到先服务</td>
</tr>
<tr>
<td>SCHED_RR</td>
<td style="text-align:center">实时调度策略，时间片轮转</td>
</tr>
</tbody>
</table>
<p><em>关于 SHCED_RR 和 SCHED_FIFO 区别</em>  </p>
<ul>
<li>当采用SHCED_RR策略的进程的时间片用完，系统将重新分配时间片,并置于就绪队列尾  </li>
<li>SCHED_FIFO一旦占用cpu则一直运行,一直运行直到有更高优先级任务到达或自己放弃</li>
</ul>
<ul>
<li><p><em>关于param参数</em></p>
<pre><code>struct sched_param {
    int sched_priority;
};
sched_priority //对应区间 ［1， 99］
</code></pre></li>
</ul>
<h2 id="0x01__u4F7F_u7528_u5B9E_u4F8B"><a href="#0x01__u4F7F_u7528_u5B9E_u4F8B" class="headerlink" title="0x01 使用实例"></a><strong>0x01</strong> 使用实例</h2><ul>
<li><p>实例说明：  </p>
<pre><code>创建的内核线程每隔一秒做一次打印

struct task_struct *test_task;  

int test_func(void *arg)
{
    uint64_t cur = 0;
    uint64_t last = 0;

    while(!kthread_should_stop())
    {
        cur = get_cycle();
        if (cur - last &gt; 2410000000)
        {
            printk(KERN_INFO &quot;this time: %llu\n&quot;, cur);
            last = cur;
        }
    }
    return 0;
}

void run_thread(void)
{
    struct sched_param param = {.sched_priority = 1};

    test_task = kthread_create(&amp;test_func, NULL, &quot;MY_test&quot;);
    kthread_bind(test_task, 0);
    sched_setscheduler(test_task, SCHED_FIFO, &amp;param);
    wake_up_process(test_task);

    printk(KERN_INFO&quot;OK, Kernel Thread : %s, Running\n&quot;, test_task-&gt;comm);
}

static int __init test_init(void)
{
    run_thread();
    return 0;
}

static void __exit test_exit(void)
{
    kthread_stop(test_task);
}

module_init(test_init);
module_exit(test_exit);
</code></pre></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00_Kernel_API"><a href="#0x00_Kernel_API" class="headerlink" title="0x00 Kernel API"></a><strong>0x00</strong> Kernel API</h2><h3 id="u4F7F_u7528_u5230_u7684_u5934_u6587_u4EF6"><a href="#u4F7F_u7528_u5230_u7684_u5934_u6587_u4EF6" class="headerlink" title="使用到的头文件"></a>使用到的头文件</h3><pre><code>#include &lt;linux/sched.h&gt;
#include &lt;linux/kthread.h&gt;
</code></pre>]]>
    
    </summary>
    
      <category term="Linux Kernel" scheme="http://http://caydyn-skd.github.io/tags/Linux-Kernel/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Github上使用Hexo搭建个人博客（MAC环境）]]></title>
    <link href="http://http://caydyn-skd.github.io/2016/01/11/%E5%9C%A8Github%E4%B8%8A%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://http://caydyn-skd.github.io/2016/01/11/在Github上使用Hexo搭建个人博客/</id>
    <published>2016-01-11T03:35:55.000Z</published>
    <updated>2016-01-12T02:52:25.000Z</updated>
    <content type="html"><![CDATA[<h2 id="0x00__u5F00_u59CB_u51C6_u5907"><a href="#0x00__u5F00_u59CB_u51C6_u5907" class="headerlink" title="0x00 开始准备"></a><strong>0x00</strong> 开始准备</h2><ul>
<li><h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><p>  因为需要用Github充当免费的静态服务器，所以这个是必须具备的</p>
<ul>
<li><strong>注册 github</strong><br>  注册链接：<a href="https://github.com/join/" target="_blank" rel="external">Join Github</a></li>
<li><strong>创建 respository</strong><br>  这里需要注意 respository 的名字为 <strong>[github用户名].github.io</strong></li>
<li><strong>下载使用 github desktop</strong><br>  下载链接：<a href="https://desktop.github.com" target="_blank" rel="external">Github Desktop</a>  </li>
</ul>
</li>
</ul>
<hr>
<a id="more"></a>
<ul>
<li><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>  下载链接: <a href="https://nodejs.org/en/download/" target="_blank" rel="external">Node.js Download</a>  </p>
</li>
</ul>
<hr>
<ul>
<li><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>  安装Hexo CLI</p>
<pre><code>npm install hexo-cli -g
</code></pre></li>
</ul>
<h2 id="0x01__u521B_u5EFA_u535A_u5BA2"><a href="#0x01__u521B_u5EFA_u535A_u5BA2" class="headerlink" title="0x01 创建博客"></a><strong>0x01</strong> 创建博客</h2><ul>
<li><h3 id="Hexo-1"><a href="#Hexo-1" class="headerlink" title="Hexo"></a>Hexo</h3><p>  <strong>初始化目录结构</strong></p>
<pre><code>npm install hexo --save
hexo init
</code></pre><p>  执行命令后，生成如下目录结构</p>
<pre><code>.
├── _config.yml
├── package.json
├── scaffolds
├── scripts
├── source
|      ├── _drafts
|      └── _posts
└── themes
</code></pre><p>  <strong>安装Hexo插件</strong>： </p>
<pre><code>npm install hexo-generator-index --save
npm install hexo-generator-archive --save  
npm install hexo-generator-category --save  
npm install hexo-generator-tag --save  
npm install hexo-server --save  
npm install hexo-deployer-git --save  
npm install hexo-deployer-heroku --save  
npm install hexo-deployer-rsync --save  
npm install hexo-deployer-openshift --save  
npm install hexo-renderer-marked@0.2 --save  
npm install hexo-renderer-stylus@0.2 --save  
npm install hexo-generator-feed@1 --save  
npm install hexo-generator-sitemap@1 --save
</code></pre><p>  <strong>测试结果</strong></p>
<pre><code>hexo server
</code></pre><p>  在浏览器中访问 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a></p>
<p>  <strong>静态文件</strong></p>
<pre><code>hexo g
</code></pre><p>  此时会生成 public 文件夹</p>
</li>
<li><h3 id="github-1"><a href="#github-1" class="headerlink" title="github"></a>github</h3><ul>
<li>使用 github desktop 软件 clone 之前创建的respository</li>
<li>将之前生成的     public 文件夹中的内容拷贝到 git 文件夹中</li>
<li>提交所有的文件</li>
<li>访问 <a href="http://[github用户名].github.io" target="_blank" rel="external">http://[github用户名].github.io</a> 查看创建好的 Blog</li>
</ul>
</li>
<li><h3 id="Hexo-2"><a href="#Hexo-2" class="headerlink" title="Hexo"></a>Hexo</h3><pre><code>hexo n &lt;title&gt; #新建文章
hexo s #本地发布预览
hexo g #生成静态文件
</code></pre></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="0x00__u5F00_u59CB_u51C6_u5907"><a href="#0x00__u5F00_u59CB_u51C6_u5907" class="headerlink" title="0x00 开始准备"></a><strong>0x00</strong> 开始准备</h2><ul>
<li><h3 id="github"><a href="#github" class="headerlink" title="github"></a>github</h3><p>  因为需要用Github充当免费的静态服务器，所以这个是必须具备的</p>
<ul>
<li><strong>注册 github</strong><br>  注册链接：<a href="https://github.com/join/">Join Github</a></li>
<li><strong>创建 respository</strong><br>  这里需要注意 respository 的名字为 <strong>[github用户名].github.io</strong></li>
<li><strong>下载使用 github desktop</strong><br>  下载链接：<a href="https://desktop.github.com">Github Desktop</a>  </li>
</ul>
</li>
</ul>
<hr>]]>
    
    </summary>
    
      <category term="Blog 搭建" scheme="http://http://caydyn-skd.github.io/tags/Blog-%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
</feed>
