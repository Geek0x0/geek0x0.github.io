<!doctype html><html class="theme-next pisces use-motion"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css"><meta name="keywords" content="Linux Kernel,"><link rel="alternate" href="/atom.xml" title="Caydyn Blog" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1"><meta name="description" content="0x01 前言
不论是在什么系统中，所有的任务都是以进程作为载体的，所以理解进程在系统中的创建过程，对于理解操作系统原理是很重要的，本文主要讲述在 Linux 操作系统中的进程创建过程。
本文使用的 Linux Kernel 版本为 3.1.8

0x02    关于PCB（Process Control Block）
PCB（进程控制块）是操作系统核心中一种数据结构，主要表示进程状态，通俗理解为"><meta property="og:type" content="article"><meta property="og:title" content="Linux Kernel 创建进程过程"><meta property="og:url" content="http://caydyn-skd.github.io/2016/07/01/Linux-Kernel-创建进程过程/index.html"><meta property="og:site_name" content="Caydyn Blog"><meta property="og:description" content="0x01 前言
不论是在什么系统中，所有的任务都是以进程作为载体的，所以理解进程在系统中的创建过程，对于理解操作系统原理是很重要的，本文主要讲述在 Linux 操作系统中的进程创建过程。
本文使用的 Linux Kernel 版本为 3.1.8

0x02    关于PCB（Process Control Block）
PCB（进程控制块）是操作系统核心中一种数据结构，主要表示进程状态，通俗理解为"><meta property="og:updated_time" content="2016-07-04T02:08:26.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Linux Kernel 创建进程过程"><meta name="twitter:description" content="0x01 前言
不论是在什么系统中，所有的任务都是以进程作为载体的，所以理解进程在系统中的创建过程，对于理解操作系统原理是很重要的，本文主要讲述在 Linux 操作系统中的进程创建过程。
本文使用的 Linux Kernel 版本为 3.1.8

0x02    关于PCB（Process Control Block）
PCB（进程控制块）是操作系统核心中一种数据结构，主要表示进程状态，通俗理解为"><script type="text/javascript" id="hexo.configuration">var NexT=window.NexT||{},CONFIG={scheme:"Pisces",sidebar:{position:"left",display:"post"},fancybox:!0,motion:!0,duoshuo:{userId:0,author:"博主"}}</script><link rel="canonical" href="http://caydyn-skd.github.io/2016/07/01/Linux-Kernel-创建进程过程/"><title> Linux Kernel 创建进程过程 | Caydyn Blog</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container one-collumn sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Caydyn Blog</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 关于</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-search"><a href="#" class="st-search-show-outputs"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><form class="site-search-form"> <input type="text" id="st-search-input" class="st-search-input st-default-search-input"></form><script type="text/javascript">!function(t,e,s,n,i,c,a){t.SwiftypeObject=i,t[i]=t[i]||function(){(t[i].q=t[i].q||[]).push(arguments)},c=e.createElement(s),a=e.getElementsByTagName(s)[0],c.async=1,c.src=n,a.parentNode.insertBefore(c,a)}(window,document,"script","//s.swiftypecdn.com/install/v2/st.js","_st"),_st("install","uuSiBvmGozaZkrsvNiu3","2.0.0")</script></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"> Linux Kernel 创建进程过程</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-07-01T15:07:36+08:00" content="2016-07-01">2016-07-01</time></span> &nbsp; | &nbsp;<span class="page-pv"><i class="fa fa-file-o"></i><span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="0x01__u524D_u8A00"><a href="#0x01__u524D_u8A00" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><ul><li>不论是在什么系统中，所有的任务都是以进程作为载体的，所以理解进程在系统中的创建过程，对于理解操作系统原理是很重要的，本文主要讲述在 Linux 操作系统中的进程创建过程。</li><li>本文使用的 Linux Kernel 版本为 3.1.8</li></ul><h3 id="0x02__u5173_u4E8EPCB_uFF08Process_Control_Block_uFF09"><a href="#0x02__u5173_u4E8EPCB_uFF08Process_Control_Block_uFF09" class="headerlink" title="0x02    关于PCB（Process Control Block）"></a>0x02 关于PCB（Process Control Block）</h3><ul><li><strong>PCB</strong>（进程控制块）是操作系统核心中一种数据结构，主要表示进程状态，通俗理解为状态记录员，当一个进程被创建时，它所属的PCB就会被分配，之后有关该进程的所有信息将会被记录在此<strong>PCB</strong>结构中，在 Linux 中 <strong>PCB</strong> 的实现结构是 <strong>task_struct</strong> 结构体，该结构体的定义可以在文件: <strong>linux-3.18_kernel/include/linux/sched.h</strong> 中查看，(在线查看： <a href="http://lxr.free-electrons.com/source/include/linux/sched.h?v=3.18" target="_blank" rel="external">http://lxr.free-electrons.com/source/include/linux/sched.h?v=3.18</a>)</li><li><strong>task_struct</strong> 的具体定义如下<a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct &#123;</span><br><span class="line">   <span class="keyword">volatile</span> <span class="keyword">long</span> state;        <span class="comment">//说明了该进程是否可以执行,还是可中断等信息</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;        <span class="comment">//进程号,在调用fork()时给出</span></span><br><span class="line">   <span class="keyword">int</span> sigpending;             <span class="comment">//进程上是否有待处理的信号</span></span><br><span class="line">   <span class="keyword">mm_segment_t</span> addr_limit;    <span class="comment">//进程地址空间,区分内核进程与普通进程在内存存放的位置不同</span></span><br><span class="line">                               <span class="comment">//0-0xBFFFFFFF for user-thead</span></span><br><span class="line">                               <span class="comment">//0-0xFFFFFFFF for kernel-thread</span></span><br><span class="line">   <span class="comment">//调度标志,表示该进程是否需要重新调度,若非0,则当从内核态返回到用户态,会发生调度</span></span><br><span class="line">   <span class="keyword">volatile</span> <span class="keyword">long</span> need_resched;</span><br><span class="line">   <span class="keyword">int</span> lock_depth;             <span class="comment">//锁深度</span></span><br><span class="line">   <span class="keyword">long</span> nice;                  <span class="comment">//进程的基本时间片</span></span><br><span class="line">   <span class="comment">//进程的调度策略,有三种,实时进程:SCHED_FIFO,SCHED_RR, 分时进程:SCHED_OTHER</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> policy;</span><br><span class="line">   <span class="keyword">struct</span> mm_struct *mm;       <span class="comment">//进程内存管理信息</span></span><br><span class="line">   <span class="keyword">int</span> processor;</span><br><span class="line">   <span class="comment">//若进程不在任何CPU上运行, cpus_runnable 的值是0，否则是1 这个值在运行队列被锁时更新</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> cpus_runnable, cpus_allowed;</span><br><span class="line">   <span class="keyword">struct</span> list_head run_list;  <span class="comment">//指向运行队列的指针</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> sleep_time;   <span class="comment">//进程的睡眠时间</span></span><br><span class="line">   <span class="comment">//用于将系统中所有的进程连成一个双向循环链表, 其根是init_task</span></span><br><span class="line">   <span class="keyword">struct</span> task_struct *next_task, *prev_task;</span><br><span class="line">   <span class="keyword">struct</span> mm_struct *active_mm;</span><br><span class="line">   <span class="keyword">struct</span> list_head local_pages;       <span class="comment">//指向本地页面      </span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">int</span> allocation_order, nr_local_pages;</span><br><span class="line">   <span class="keyword">struct</span> linux_binfmt *binfmt;        <span class="comment">//进程所运行的可执行文件的格式</span></span><br><span class="line">   <span class="keyword">int</span> exit_code, exit_signal;</span><br><span class="line">   <span class="keyword">int</span> pdeath_signal;                  <span class="comment">//父进程终止是向子进程发送的信号</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> personality;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">int</span> did_exec:<span class="number">1</span>; </span><br><span class="line">   <span class="keyword">pid_t</span> pid;                          <span class="comment">//进程标识符,用来代表一个进程</span></span><br><span class="line">   <span class="keyword">pid_t</span> pgrp;                         <span class="comment">//进程组标识,表示进程所属的进程组</span></span><br><span class="line">   <span class="keyword">pid_t</span> tty_old_pgrp;                 <span class="comment">//进程控制终端所在的组标识</span></span><br><span class="line">   <span class="keyword">pid_t</span> session;                      <span class="comment">//进程的会话标识</span></span><br><span class="line">   <span class="keyword">pid_t</span> tgid;</span><br><span class="line">   <span class="keyword">int</span> leader;                         <span class="comment">//表示进程是否为会话主管</span></span><br><span class="line">   <span class="keyword">struct</span> task_struct *p_opptr,*p_pptr,*p_cptr,*p_ysptr,*p_osptr;</span><br><span class="line">   <span class="keyword">struct</span> list_head thread_group;      <span class="comment">//线程链表</span></span><br><span class="line">   <span class="keyword">struct</span> task_struct *pidhash_next;   <span class="comment">//用于将进程链入HASH表</span></span><br><span class="line">   <span class="keyword">struct</span> task_struct **pidhash_pprev;</span><br><span class="line">   <span class="keyword">wait_queue_head_t</span> wait_chldexit;    <span class="comment">//供wait4()使用</span></span><br><span class="line">   <span class="keyword">struct</span> completion *vfork_done;      <span class="comment">//供vfork() 使用</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> rt_priority;          <span class="comment">//实时优先级，用它计算实时进程调度时的weight值</span></span><br><span class="line">   …… <span class="comment">//后面就不看了 我们不关心</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="0x03__u8FDB_u7A0B_u521B_u5EFA_u5206_u6790"><a href="#0x03__u8FDB_u7A0B_u521B_u5EFA_u5206_u6790" class="headerlink" title="0x03 进程创建分析"></a>0x03 进程创建分析</h3><ul><li>系统中进程都是基于父进程调用 <strong>fork()</strong> 函数创建的，被创建出来的新进程叫做<strong>子进程</strong>。</li><li><p>以下是一段关于使用 <strong>fork()</strong> 的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="comment">/* fork another process */</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">/* error occurred */</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Fork Failed!"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(-<span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* child process */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This is Child Process!\n"</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">/* parent process  */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"This is Parent Process!\n"</span>);</span><br><span class="line">        <span class="comment">/* parent will wait for the child to complete*/</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Child Complete!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用 <strong>fork()</strong> 函数后通过0x80中断（系统调用中断）从用户态陷入内核态，从而使用系统提供的相应系统调用来完成进程的创建。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> __ARCH_WANT_SYS_VFORK</span></span><br><span class="line">SYSCALL_DEFINE0(vfork)</span><br><span class="line">&#123;</span><br><span class="line">         <span class="keyword">return</span> _do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, <span class="number">0</span>,</span><br><span class="line">                        <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="preprocessor">#<span class="keyword">ifdef</span> __ARCH_WANT_SYS_CLONE</span></span><br><span class="line"> <span class="preprocessor">#<span class="keyword">ifdef</span> CONFIG_CLONE_BACKWARDS</span></span><br><span class="line"> SYSCALL_DEFINE5(clone, <span class="keyword">unsigned</span> <span class="keyword">long</span>, clone_flags, <span class="keyword">unsigned</span> <span class="keyword">long</span>, newsp,</span><br><span class="line">                  <span class="keyword">int</span> __user *, parent_tidptr,</span><br><span class="line">                  <span class="keyword">unsigned</span> <span class="keyword">long</span>, tls,</span><br><span class="line">                  <span class="keyword">int</span> __user *, child_tidptr)</span><br><span class="line"> <span class="preprocessor">#<span class="keyword">elif</span> defined(CONFIG_CLONE_BACKWARDS2)</span></span><br><span class="line"> SYSCALL_DEFINE5(clone, <span class="keyword">unsigned</span> <span class="keyword">long</span>, newsp, <span class="keyword">unsigned</span> <span class="keyword">long</span>, clone_flags,</span><br><span class="line">                  <span class="keyword">int</span> __user *, parent_tidptr,</span><br><span class="line">                  <span class="keyword">int</span> __user *, child_tidptr,</span><br><span class="line">                  <span class="keyword">unsigned</span> <span class="keyword">long</span>, tls)</span><br><span class="line"> <span class="preprocessor">#<span class="keyword">elif</span> defined(CONFIG_CLONE_BACKWARDS3)</span></span><br><span class="line"> SYSCALL_DEFINE6(clone, <span class="keyword">unsigned</span> <span class="keyword">long</span>, clone_flags, <span class="keyword">unsigned</span> <span class="keyword">long</span>, newsp,</span><br><span class="line">                 <span class="keyword">int</span>, stack_size,</span><br><span class="line">                 <span class="keyword">int</span> __user *, parent_tidptr,</span><br><span class="line">                 <span class="keyword">int</span> __user *, child_tidptr,</span><br><span class="line">                 <span class="keyword">unsigned</span> <span class="keyword">long</span>, tls)</span><br><span class="line"> <span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line"> SYSCALL_DEFINE5(clone, <span class="keyword">unsigned</span> <span class="keyword">long</span>, clone_flags, <span class="keyword">unsigned</span> <span class="keyword">long</span>, newsp,</span><br><span class="line">                  <span class="keyword">int</span> __user *, parent_tidptr,</span><br><span class="line">                  <span class="keyword">int</span> __user *, child_tidptr,</span><br><span class="line">                  <span class="keyword">unsigned</span> <span class="keyword">long</span>, tls)</span><br><span class="line"> <span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line"> &#123;</span><br><span class="line">         <span class="keyword">return</span> _do_fork(clone_flags, newsp, <span class="number">0</span>, parent_tidptr, child_tidptr, tls);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><p>无论是通过<strong>fork()</strong>或者是<strong>vfork()</strong>创建的进程，最终都是通过调用<strong>do_fork()</strong>做最终的action，下面来查看下<strong>do_fork()</strong>的实现</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">do_fork</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,</span><br><span class="line">              <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span><br><span class="line">              <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,</span><br><span class="line">              <span class="keyword">int</span> __user *parent_tidptr,</span><br><span class="line">              <span class="keyword">int</span> __user *child_tidptr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">		<span class="comment">//创建进程描述符指针</span></span><br><span class="line">        <span class="keyword">struct</span> task_struct *p;</span><br><span class="line">        <span class="keyword">int</span> trace = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> nr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * Determine whether and which event to report to ptracer.  When</span><br><span class="line">         * called from kernel_thread or CLONE_UNTRACED is explicitly</span><br><span class="line">         * requested, no event is reported; otherwise, report if the event</span><br><span class="line">         * for the type of forking is enabled.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!(clone_flags &amp; CLONE_UNTRACED)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK)</span><br><span class="line">                        trace = PTRACE_EVENT_VFORK;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((clone_flags &amp; CSIGNAL) != SIGCHLD)</span><br><span class="line">                        trace = PTRACE_EVENT_CLONE;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        trace = PTRACE_EVENT_FORK;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (likely(!ptrace_event_enabled(current, trace)))</span><br><span class="line">                        trace = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//复制进程描述符，copy_process()的返回值是一个 task_struct 指针</span></span><br><span class="line">        p = copy_process(clone_flags, stack_start, stack_size,</span><br><span class="line">                         child_tidptr, <span class="literal">NULL</span>, trace);</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * Do this prior waking up the new thread - the thread pointer</span><br><span class="line">         * might get invalid after that point, if the thread exits quickly.</span><br><span class="line">        */</span></span><br><span class="line">        <span class="keyword">if</span> (!IS_ERR(p)) &#123;</span><br><span class="line">                <span class="keyword">struct</span> completion vfork;</span><br><span class="line">                <span class="keyword">struct</span> pid *pid;</span><br><span class="line"></span><br><span class="line">                trace_sched_process_fork(current, p);</span><br><span class="line">					<span class="comment">//得到新创建的进程描述符中的pid</span></span><br><span class="line">                pid = get_task_pid(p, PIDTYPE_PID);</span><br><span class="line">                nr = pid_vnr(pid);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (clone_flags &amp; CLONE_PARENT_SETTID)</span><br><span class="line">                        put_user(nr, parent_tidptr);</span><br><span class="line">					<span class="comment">//如果调用的 vfork()方法，初始化 vfork 完成处理信息。</span></span><br><span class="line">                <span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">                        p-&gt;vfork_done = &amp;vfork;</span><br><span class="line">                        init_completion(&amp;vfork);</span><br><span class="line">                        get_task_struct(p);</span><br><span class="line">                &#125;</span><br><span class="line">					<span class="comment">//将子进程加入到调度器中，为其分配 CPU，准备执行</span></span><br><span class="line">                wake_up_new_task(p);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* forking complete and child started to run, tell ptracer */</span></span><br><span class="line">                <span class="comment">//fork 完成，子进程即将开始运行</span></span><br><span class="line">                <span class="keyword">if</span> (unlikely(trace))</span><br><span class="line">                        ptrace_event_pid(trace, pid);</span><br><span class="line">					<span class="comment">//如果是 vfork，将父进程加入至等待队列，等待子进程完成</span></span><br><span class="line">                <span class="keyword">if</span> (clone_flags &amp; CLONE_VFORK) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!wait_for_vfork_done(p, &amp;vfork))</span><br><span class="line">                                ptrace_event_pid(PTRACE_EVENT_VFORK_DONE, pid);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                put_pid(pid);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nr = PTR_ERR(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>do_fork()</strong>中首先会进行一些健壮性检查后，调用<strong>copy_process()</strong>，完成进程数据结构和其他资源的初始化工作，初始化可以是重新分配新的资源，或者是与父进程共享资源，这个由<strong>clone_flags</strong>参数决定，最后调用 <strong>wake_up_new_task()</strong> 将子进程加入调度器中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">struct</span> task_struct *<span class="title">copy_process</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags,</span><br><span class="line">          <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_start,</span><br><span class="line">          <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_size,</span><br><span class="line">          <span class="keyword">int</span> __user *child_tidptr,</span><br><span class="line">          <span class="keyword">struct</span> pid *pid,</span><br><span class="line">          <span class="keyword">int</span> trace)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> retval;</span><br><span class="line">  <span class="keyword">struct</span> task_struct *p;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//分配一个新的 task_struct，此时的p与当前进程的 task，仅仅是 stack 地址不同</span></span><br><span class="line">  p = dup_task_struct(current);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//检查该用户的进程数是否超过限制</span></span><br><span class="line">  <span class="keyword">if</span> (atomic_read(&amp;p-&gt;real_cred-&gt;user-&gt;processes) &gt;=</span><br><span class="line">      task_rlimit(p, RLIMIT_NPROC)) &#123;</span><br><span class="line">    <span class="comment">//检查该用户是否具有相关权限，不一定是 root</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;real_cred-&gt;user != INIT_USER &amp;&amp;</span><br><span class="line">        !capable(CAP_SYS_RESOURCE) &amp;&amp; !capable(CAP_SYS_ADMIN))</span><br><span class="line">      <span class="keyword">goto</span> bad_fork_free;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  retval = -EAGAIN;</span><br><span class="line">  <span class="comment">//检查进程数量是否超过 max_threads，后者取决于内存的大小</span></span><br><span class="line">  <span class="keyword">if</span> (nr_threads &gt;= max_threads)</span><br><span class="line">    <span class="keyword">goto</span> bad_fork_cleanup_count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//完成对新进程调度程序数据结构的初始化，并把新进程的状态设置为TASK_RUNNING</span></span><br><span class="line">  retval = sched_fork(clone_flags, p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化子进程的内核栈</span></span><br><span class="line">  retval = copy_thread(clone_flags, stack_start, stack_size, p);</span><br><span class="line">  <span class="keyword">if</span> (retval)</span><br><span class="line">    <span class="keyword">goto</span> bad_fork_cleanup_io;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid != &amp;init_struct_pid) &#123;</span><br><span class="line">    retval = -ENOMEM;</span><br><span class="line">    <span class="comment">//这里为子进程分配了新的 pid 号</span></span><br><span class="line">    pid = alloc_pid(p-&gt;nsproxy-&gt;pid_ns_for_children);</span><br><span class="line">    <span class="keyword">if</span> (!pid)</span><br><span class="line">      <span class="keyword">goto</span> bad_fork_cleanup_io;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置子进程的 pid</span></span><br><span class="line">  p-&gt;pid = pid_nr(pid);</span><br><span class="line">  <span class="comment">//如果是创建线程</span></span><br><span class="line">  <span class="keyword">if</span> (clone_flags &amp; CLONE_THREAD) &#123;</span><br><span class="line">    p-&gt;exit_signal = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//线程组的 leader 设置为当前线程的 leader</span></span><br><span class="line">    p-&gt;group_leader = current-&gt;group_leader;</span><br><span class="line">    <span class="comment">//tgid 是当前线程组的 id，也就是 main 进程的 pid</span></span><br><span class="line">    p-&gt;tgid = current-&gt;tgid;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (clone_flags &amp; CLONE_PARENT)</span><br><span class="line">      p-&gt;exit_signal = current-&gt;group_leader-&gt;exit_signal;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      p-&gt;exit_signal = (clone_flags &amp; CSIGNAL);</span><br><span class="line">    <span class="comment">//创建的是进程，自己是一个单独的线程组</span></span><br><span class="line">    p-&gt;group_leader = p;</span><br><span class="line">    <span class="comment">//tgid 和 pid 相同</span></span><br><span class="line">    p-&gt;tgid = p-&gt;pid;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (clone_flags &amp; (CLONE_PARENT|CLONE_THREAD)) &#123;</span><br><span class="line">    <span class="comment">//如果是创建线程，那么同一线程组内的所有线程、进程共享 parent</span></span><br><span class="line">    p-&gt;real_parent = current-&gt;real_parent;</span><br><span class="line">    p-&gt;parent_exec_id = current-&gt;parent_exec_id;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果是创建进程，当前进程就是子进程的 parent</span></span><br><span class="line">    p-&gt;real_parent = current;</span><br><span class="line">    p-&gt;parent_exec_id = current-&gt;self_exec_id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将 pid 加入 PIDTYPE_PID 这个散列表</span></span><br><span class="line">  attach_pid(p, PIDTYPE_PID);</span><br><span class="line">  <span class="comment">//递增 nr_threads 的值</span></span><br><span class="line">  nr_threads++;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回被创建的 task 结构体指针</span></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>copy_process()</strong> 函数执行过程</p><ul><li>调用 <strong>dup_task_struct()</strong> 复制当前的 task_struct；</li><li>调用 <strong>sched_fork()</strong> 初始化进程数据结构，并把进程状态设置为 TASK_RUNNING；</li><li>复制父进程的所有信息；</li><li>调用 copy_thread 初始化子进程内核栈；</li><li>为新进程分配并设置新的 pid；</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">struct</span> task_struct *<span class="title">dup_task_struct</span><span class="params">(<span class="keyword">struct</span> task_struct *orig)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> task_struct *tsk;</span><br><span class="line">	<span class="keyword">struct</span> thread_info *ti;</span><br><span class="line">	<span class="keyword">int</span> node = tsk_fork_get_node(orig);</span><br><span class="line">	<span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//分配一个 task_struct 节点</span></span><br><span class="line">	tsk = alloc_task_struct_node(node);</span><br><span class="line">	<span class="keyword">if</span> (!tsk)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//分配一个 thread_info 节点，包含进程的内核栈，ti 为栈底</span></span><br><span class="line">	ti = alloc_thread_info_node(tsk, node);</span><br><span class="line">	<span class="keyword">if</span> (!ti)</span><br><span class="line">		<span class="keyword">goto</span> free_tsk;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将栈底的值赋给新节点的栈</span></span><br><span class="line">	tsk-&gt;<span class="built_in">stack</span> = ti;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//……</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> tsk;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>dup_task_struct()</strong> 函数执行过程<ul><li>调用 <strong>alloc_task_struct_node()</strong> 分配一个 task_struct 节点</li><li>调用 <strong>alloc_thread_info_node()</strong> 分配一个 thread_info 节点，其实是分配了一个thread_union联合体,将栈底返回给 ti</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_thread</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> clone_flags, <span class="keyword">unsigned</span> <span class="keyword">long</span> sp,</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> arg, <span class="keyword">struct</span> task_struct *p)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取寄存器信息</span></span><br><span class="line">  <span class="keyword">struct</span> pt_regs *childregs = task_pt_regs(p);</span><br><span class="line">  <span class="keyword">struct</span> task_struct *tsk;</span><br><span class="line">  <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 栈顶 空栈</span></span><br><span class="line">  p-&gt;thread.sp = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) childregs;</span><br><span class="line">  p-&gt;thread.sp0 = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (childregs+<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">memset</span>(p-&gt;thread.ptrace_bps, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;thread.ptrace_bps));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是创建的内核线程</span></span><br><span class="line">  <span class="keyword">if</span> (unlikely(p-&gt;flags &amp; PF_KTHREAD)) &#123;</span><br><span class="line">    <span class="comment">/* kernel thread */</span></span><br><span class="line">    <span class="built_in">memset</span>(childregs, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pt_regs));</span><br><span class="line">    <span class="comment">// 内核线程开始执行的位置</span></span><br><span class="line">    p-&gt;thread.ip = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) ret_from_kernel_thread;</span><br><span class="line">    task_user_gs(p) = __KERNEL_STACK_CANARY;</span><br><span class="line">    childregs-&gt;ds = __USER_DS;</span><br><span class="line">    childregs-&gt;es = __USER_DS;</span><br><span class="line">    childregs-&gt;fs = __KERNEL_PERCPU;</span><br><span class="line">    childregs-&gt;bx = sp; <span class="comment">/* function */</span></span><br><span class="line">    childregs-&gt;bp = arg;</span><br><span class="line">    childregs-&gt;orig_ax = -<span class="number">1</span>;</span><br><span class="line">    childregs-&gt;cs = __KERNEL_CS | get_kernel_rpl();</span><br><span class="line">    childregs-&gt;flags = X86_EFLAGS_IF | X86_EFLAGS_FIXED;</span><br><span class="line">    p-&gt;thread.io_bitmap_ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将当前进程的寄存器信息复制给子进程</span></span><br><span class="line">  *childregs = *current_pt_regs();</span><br><span class="line">  <span class="comment">// 子进程的eax置为0，所以fork的子进程返回值为0</span></span><br><span class="line">  childregs-&gt;ax = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (sp)</span><br><span class="line">    childregs-&gt;sp = sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子进程从ret_from_fork开始执行</span></span><br><span class="line">  p-&gt;thread.ip = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) ret_from_fork;</span><br><span class="line">  task_user_gs(p) = get_user_gs(current_pt_regs());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>copy_thread()</strong> 函数用意<ul><li>为什么 fork 在子进程中返回 0，原因是 childregs-&gt;ax = 0 这句话，把子进程的 eax 赋值为 0。</li><li>p-&gt;thread.ip = (unsigned long) ret_from_fork， 将子进程的 ip 设置为 ret_form_fork 的首地址，因此子进程是从 ret_from_fork 开始执行的。</li></ul></li></ul><h3 id="0x04__u5C0F_u7ED3"><a href="#0x04__u5C0F_u7ED3" class="headerlink" title="0x04 小结"></a>0x04 小结</h3><p>Linux 创建进程的重要阶段:</p><ul><li><strong>do_fork()</strong> 系统内核调用.</li><li><strong>copy_process()</strong> 复制父进程的所有信息给子进程.</li><li><strong>dup_task_struct()</strong> 中为子进程分配了新的堆栈.</li><li>调用 <strong>sched_fork()</strong> 并把新进程设置为 TASK_RUNNING.</li><li><strong>copy_thread()</strong> 中把父进程的寄存器上下文复制给子进程.</li><li>设置 <strong>ret_from_fork()</strong> 的地址为 eip 寄存器的值.</li></ul></div><div></div><div></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/Linux-Kernel/" rel="tag">#Linux Kernel</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2016/06/23/关于WANem简单实用/" rel="next" title="关于WANem简单实用"><i class="fa fa-chevron-left"></i> 关于WANem简单实用</a></div><div class="post-nav-prev post-nav-item"></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview"> 站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/head.png" alt="Caydyn"><p class="site-author-name" itemprop="name">Caydyn</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">8</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags"><span class="site-state-item-count">7</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/caydyn-skd" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="http://weibo.com/372145087/" target="_blank" title="Weibo"><i class="fa fa-fw fa-weibo"></i> Weibo</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-globe"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"> <a href="http://fuxiao.xyz/blog/" title="Jerry.f的博客" target="_blank">Jerry.f的博客</a></li><li class="links-of-blogroll-item"> <a href="http://www.dengyongrui.com/" title="Yongrui Deng的博客" target="_blank">Yongrui Deng的博客</a></li></ul></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#0x01__u524D_u8A00"><span class="nav-number">1.</span> <span class="nav-text">0x01 前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x02__u5173_u4E8EPCB_uFF08Process_Control_Block_uFF09"><span class="nav-number">2.</span> <span class="nav-text">0x02 关于PCB（Process Control Block）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x03__u8FDB_u7A0B_u521B_u5EFA_u5206_u6790"><span class="nav-number">3.</span> <span class="nav-text">0x03 进程创建分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x04__u5C0F_u7ED3"><span class="nav-number">4.</span> <span class="nav-text">0x04 小结</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2015 - <span itemprop="copyrightYear">2016</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">Caydyn</span></div><div class="powered-by"> 由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info"> 主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div><div class="busuanzi-count"><script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span><span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script><script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script><script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>